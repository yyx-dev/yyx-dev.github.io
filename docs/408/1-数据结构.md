# 数据结构

## 第一章 绪论

1. 常见概念

- 数据：输入的所有内容
- 数据元素：数据的基本单位，一条记录
- 数据项：单条记录中的每个项目


2. 时间复杂度

```c
// O(logn)
for (int i=0; i<=n; i*=2)
    k++;
```

```c
// O(m+n)
// O(max(m,n))
for (int i=0; i<=m; i++)
    k++;
for (int i=0; i<=n; i++)
    k++;
```

```c
// O(n^2)
for (int i=0; i<n; i++)
    for (int j=0; j<i; j++)
        k++;
// 频次 n(n+1)/2
```

```c
//O(√n)
while (i*i<n)
    i++;
```

3. 空间复杂度（只考虑额外开辟的辅助空间）

```c
// O(1)
void BubbleSort(int A[],int n) {
    for (int i=0;i<n-1;i++) {
        bool flag=false;
        for(int j=n-1;j>i;j--)
            ...
```

```c
// O(n)
int Func(int n) {
    if (n == 0) return 1;
    return Func(n-1) * n;
}
// 递归栈空间消耗
```

```c
// O(n)
int Fib(int n) {
    if(n < 3) return 1;
	return Fib(n-1) * Fib(n-2);
}
// 递归栈可以重复利用
```

## 第二章 线性表

1. 顺序表

- 插入：平均移动次数为<mark>$\frac{n}{2}$</mark>，时间复杂度为 $O(n)$.
- 删除：平均移动次数为<mark>$\frac{n-1}{2}$</mark>，时间复杂度为 $O(n)$.
- 查找：支持<mark>随机存取</mark>，复杂度为 $O(1)$.

> 插入删除第 $i$ 个元素时，要移动 $n-i$ 个元素。

2. 链表

| 数据结构           | 头插   | 头删   | 尾插   | 尾删   | 中间位置插入 | 中间位置删除 |
| ------------------ | ------ | ------ | ------ | ------ | ------------ | ------------ |
| （带头）单/双链表  | $O(1)$ | $O(1)$ | $O(n)$ | $O(n)$ | $O(n)$       | $O(n)$       |
| （带头）循环单链表 | $O(n)$ | $O(n)$ | $O(n)$ | $O(n)$ | $O(n)$       | $O(n)$       |
| （带头）循环双链表 | $O(1)$ | $O(1)$ | $O(1)$ | $O(1)$ | $O(n)$       | $O(n)$       |

## 第三章 栈、队列和矩阵

### 栈

$n$ 个元素进栈时，出栈排列个数为 $\frac{1}{n+1}C^{n}_{2n}$（卡特兰数）。

| 栈操作 | 初始Top=-1 | 初始Top=0  |
| ------ | ---------- | ---------- |
| 入栈   | a[++top]=x | a[top++]=x |
| 出栈   | a[top--]=x | a[--top]=x |
| 读栈   | a[top]     | a[top-1]   |
| 个数   | top+1      | top        |
| 判空   | top==-1    | top==-1    |

[括号匹配](https://leetcode.cn/problems/valid-parentheses/solutions/3897597/ji-jian-gua-hao-pi-pei-wen-ti-by-yyx_dev-nrgt/)

[中缀转后缀、后缀表达式求值](https://leetcode.cn/problems/evaluate-reverse-polish-notation/solutions/3897777/zhong-zhui-zhuan-hou-zhui-hou-zhui-biao-0wu9h/)

### 队列

| 循环队列 | 操作（Maxsize表示空间容量/数组大小） |
| -------- | ------------------------------------ |
| 入队     | $(rear+1)\%MaxSize$                  |
| 出队     | $(front+1)\%MaxSize$                 |
| 判空     | $front==rear$                        |
| 判满     | $front==(rear+1)\%MaxSize$           |
| 个数     | $(rear-front+MaxSize)\%MaxSize$      |

<center>
<img src="./1-数据结构.assets/循环队列过程.png" alt="image-20260207105501998" style="zoom: 67%;" />
</center>

### 矩阵

1. 数组

::: tip
`a[1...n]`和`a[1:n]`都表示下标从1到n，共n个元素。
:::

设二维数组有n行m列（每行m个元素、每列n个元素）：

- 若按行优先存放，则 $a[i][j]$ 的地址为 $a + (i*m + j)*L$.
- 若按列优先存放，则 $a[i][j]$ 的地址为 $a + (j*n + i)*L$.

> $a_{ij}$ 压缩存储在数组 B[k] 中，i j 和 k 的关系。

<center>
<img src="./1-数据结构.assets/四种特殊矩阵.png" style="zoom: 50%;" />
</center>

2. 对阵矩阵 / 三角矩阵

| 存储方式       | 对应法则                                   |
| -------------- | ------------------------------------------ |
| 下三角按行存储 | $k=(1+2+...+i-1)+j-1=\frac{i(i-1)}{2}+j-1$ |
| 上三角按列存储 | $k=(1+2+...+j-1)+i-1=\frac{j(j-1)}{2}+i-1$ |

三角矩阵最后一个元素放另一半三角的常数。

3. 稀疏矩阵

三元组存储行下标、列下表和元素值，**下标从0开始**，始终按**第一列升序排序**。

<center>
<img src="./1-数据结构.assets/稀疏矩阵三元组.png" style="zoom: 50%;" />
</center>

4. 三对角矩阵

按行压缩，下标对应关系 $k=2\times1+3\times(i-2)+0或1$ 。

> 第一行和末尾行只有2个，中间行都是3个元素。

## 第四章 串

<center>
<img src="./1-数据结构.assets/KMP模式串移动.png" style="zoom:80%;" />
</center>

1. PM：从开头到当前位置的子串，其最长公共前后缀的长度。

<center>
<img src="./1-数据结构.assets/PM数组.png" style="zoom:80%;" />
</center>

2. next：

- 法一：PM数组整体右移一位，开头补$-1$，再整体加 $1$ 。
- 法二：失配位置前的子串，其最大公共前后缀的长度再加 $1$ 。

> 默认下标从1开始，若从0开始，则不用整体加一。

<center>
<img src="./1-数据结构.assets/next数组.png" style="zoom:80%;" />
</center>

3. nextval：

- 第一位是 $0$
- 其他位根据 next，找到对应的元素，相同则取其 nextval，不同取自身 next。

## 第五章 树

1. 树的性质

- $结点总数=总度数+1=分支数+1$
- $树的度为k，结点数为n，则树的最大高度为\bbox[yellow]{n-k+1}$

2. 二叉树的性质

- $二叉树第i层结点数最多为\bbox[yellow]{2^{i-1}}，结点总数最多为\bbox[yellow]{2^h-1}$
- $任意二叉树中，\bbox[yellow]{n_0=n_2+1}$
- $完全二叉树中，\bbox[yellow]{n_1=0或1}。n为偶数则n_1=1，n为奇数则n_1=0$
- $完全二叉树中，2^{h-1}-1<n≤2^{h}-1，即\bbox[yellow]{h=\lceil log_2(n+1) \rceil} 或 \bbox[yellow]{\lfloor log_2n\rfloor + 1}$
- $不管以任何方式遍历二叉树，\bbox[yellow]{叶结点的相对顺序不变}$

3. 树、森林转二叉树（左孩子，右兄弟）

- 左叉连最左侧的子结点
- 最左子结点右叉连右侧所有子结点

<center>
<img src="./1-数据结构.assets/树转二叉树.png" style="zoom: 50%;" />
</center>

- 森林中每棵树先转，第一树右叉连右侧所有树

<center>
<img src="./1-数据结构.assets/森林转二叉树.png" style="zoom:60%;" />
</center>

4. 树、森林的遍历

- $树和森林的先序遍历=二叉树的先序遍历$
- $树和森林的\bbox[yellow]{后}序遍历=二叉树的\bbox[yellow]{中}序遍历$

5. 线索二叉树

> 线索用来指向遍历序列中前驱和后继，故分为先/中/后序线索二叉树。

方法：

- 将所有结点的空指针利用起来，
- 空左指针指向前驱，并置ltag为1，空右指针指向后继，并置rtag为1。

<center>
<img src="./1-数据结构.assets/线索二叉树.png" style="zoom: 80%;" alt="中序线索二叉树"/>
</center>

性质：

- 中序线索二叉树可以直接遍历
- **先序**线索二叉树**不支持直接找前驱**
- **后序**线索二叉树**不支持直接找后继**，需借助栈保存父结点信息

6. 哈夫曼树

> - 结点的带权路径长度：结点权重 * 结点到根的路径长度
> - 树的带权路径长度：所有叶节点的带权路径长度之和

构建：

- 找到权值最小的两个结点，组合成树，根的权值为两结点权值之和（只看根节点）
- 将树放入集合中，重复上述步骤

<center>
<img src="./1-数据结构.assets/构建哈夫曼树.png" style="zoom: 80%;" />
</center>

性质：

- 哈夫曼树的带权路径长度 WPL 最小
- 共 $n$ 个结点，构造过程中新建了 $n-1$ 个结点，最终哈夫曼树共 $2n-1$ 个结点
- 哈夫曼树只有度为 $0$ 和 $1$ 的结点，即 $n=n_0+n_2$
- 权值越小的结点离根越远

7. 哈夫曼编码

> 结点权值仅用于构建哈夫曼树，编码过程不涉及权值。

- 从根向下设左分支为0，右分支为1
- 从根到叶的路径编码，即该叶的编码

<center>
<img src="./1-数据结构.assets/哈夫曼编码.png" style="zoom: 50%;" />
</center>
## 第六章 图



## 第七章 查找



## 第八章 排序
